Get_next_line


> 선언부

파일 디스크립터별로 각각의 차 포인터를 가리킬 수 있는 배열을 만든다.
    static char     fd_backup[OPEN_MAX];
- EOF까지 돈 파일은 null 로 만들어줘야 함




> 이전에 남은 버퍼가 있을 경우, 먼저 넣는 과정

해당 차 포인터에는 각각 \n까지 읽고 남은 버퍼를 저장한다.
해당 포인터가 0이 아니면, 남은 버퍼를 line에 붙인다. 


If (fd_backup[fd] != 0)
{
	만약 버퍼를 붙이는 과정에서 \n을 만난 경우, 해당 부분까지만 붙이고 리턴 1
		- split_nl
	끝까지 붙인 경우, 해당 포인터를 \0으로 만들고 다음 단계로 넘어감
	
	flag = split_nl;
	if (flag == 0)
	{
		return (0);
	}
	else (flag == -1)
	{
		free_alloc();
		return (-1);
	}
}

Else
{
	if (!(*Line = (char *)malloc(1)))
		return (-1);
	**Line = 0;
}



> 남은 버퍼 해결 후, 새로운 버퍼 붙이는 과정

해당 포인터가 0을 가리키면, 읽고 담는 과정으로 넘어간다.


While (read_size = read > 0) 일단 읽은 거 자체를 buffer에 담는다
{
	버퍼에 담은 것 중에서 \n 전까지는 line으로 옮기고, 
	\n 이후의 것은 fd_backup에 저장하기

	if ()
		break;
	EOF 가 아닌데 끝내야 하는 경우, break 걸어서 탈출
		- 중간에 error, 
		- \n을 만남
}



> EOF
처음부터 read_size > 0 일 때, EOF
If (read_size == 0)
	return (0);



> error 난 경우, free하는 과정
If ()
{
	free();
}



> utils
1. 두 개로 쪼개고 붙이는 함수: split_nl
	char	*split_nl(char *dst, char *src); 
	- /n 만났을 경우, 0 리턴
	- 만나지 않았을 경우, 1 리턴 + dst에 다 넣고 src는 free로 만들고 null가리키기
		fd_backup[fd] = 0;	

	- error  날 경우, -1 리턴
	- src 로 들어온 건, 함수 내에서 src = 뒷부분 붙이기

2. 

